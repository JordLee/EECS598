
<!-- |\/| |\/| |\/| |\/| |\/| |\/| |\/| |\/| |\/| |\/| |\/| |\/| |\/| |\/| |\/|

    Pendularm 1 simulation 
        
    Example of 1 DOF dynamics and control in HTML5/JavaScript and threejs

    @author ohseejay / https://github.com/ohseejay / https://bitbucket.org/ohseejay

    Chad Jenkins
    Laboratory for Perception RObotics and Grounded REasoning Systems
    University of Michigan

    License: Creative Commons 3.0 BY-SA

|\/| |\/| |\/| |\/| |\/| |\/| |\/| |\/| |\/| |\/| |\/| |\/| |\/| |\/| |\/| -->

<html>

<body>

<!-- //////////////////////////////////////////////////
     /////     JAVASCRIPT INCLUDES
     ////////////////////////////////////////////////// -->


<!-- threejs - https://github.com/mrdoob/three.js/ -->
<script src="js/three.min.js"></script>

<!-- threejs camera controls helpers -->
<script src="js/OrbitControls.js"></script>

<!-- threejs keyboard input helper -->
<script src="js/THREEx.KeyboardState.js"></script>

<script>

//////////////////////////////////////////////////
/////     MAIN FUNCTION CALLS
//////////////////////////////////////////////////

// initialize threejs scene, user input, and robot kinematics
init();

// main animation loop maintained by threejs 
animate();


//////////////////////////////////////////////////
/////     INITIALIZATION FUNCTION DEFINITONS
//////////////////////////////////////////////////

function init() {

    // create pendulum object and its kinematic and dynamic parameters
    pendulum = {length:2.0, mass:2.0, angle:Math.PI/2, angle_dot:0.0, angle_previous:0};

    
    pendulum_2 = {length:2.0, mass:2.0, angle:Math.PI/2, angle_dot:0.0, angle_previous:0};

    // initialize pendulum controls
    pendulum.control = 0;
    pendulum.desired = -Math.PI/2.5;
    pendulum.desired_dot = 0;

    // initialize integral term accumulated error to zeroi
    accumulated_error = 0;

    // set gravity
    gravity = 9.81;  // Earth gravity

    // initialize pendulum PID servo gains
    pendulum.servo = {kp:100, kd:10, ki:0.1};  // no control

    // initialize time and set timestep 
    t = 0;
    dt = 0.05;  // default
 
    // initialize method of numerical integration of dynamics
    //numerical_integrator = "euler";
    //numerical_integrator = "verlet";
    //numerical_integrator = "velocity verlet";
    //numerical_integrator = "runge-kutta";

    // OPTIONAL servo controller additional features
    steady_state_error_reset = false; // integral term resets after desired met
    servo_error_threshold = 0.001; // threshold for achieving desired
    servo_active_persist = false; // toggle to turn on servo controller
    servo_active_state = {}; // string with current state of servo activation

    //STENCIL: for verlet integration, a first step in time is needed
    ver_state = true;
   
 // initialize rendering scene and user interface
    createScene();

}


//////////////////////////////////////////////////
/////     ANIMATION AND INTERACTION LOOP
//////////////////////////////////////////////////

function animate() {

    // note: three.js includes requestAnimationFrame shim
    // alternative to using setInterval for updating in-browser drawing
    // this effectively request that the animate function be called again for next draw
    // http://learningwebgl.com/blog/?p=3189
    requestAnimationFrame( animate );

    // switch between numerical integrators based on user input
    if (keyboard.pressed("0"))
        numerical_integrator = "none";
    if (keyboard.pressed("1"))
        numerical_integrator = "euler";
    if (keyboard.pressed("2"))
        numerical_integrator = "verlet";
    if (keyboard.pressed("3"))
        numerical_integrator = "velocity verlet";
    if (keyboard.pressed("4"))
        numerical_integrator = "runge-kutta";

    // update servo desired state from user interaction 
    if ( keyboard.pressed("e") )
        pendulum.desired += 0.05; // move the desired angle for the servo
    if ( keyboard.pressed("q") )
        pendulum.desired += -0.05; // move the desired angle for the servo


    // add user force from user interaction
    if ( keyboard.pressed("d") )
        pendulum.control += 50.0;  // add a motor force to the pendulum motor
    else if ( keyboard.pressed("a") )
        pendulum.control += -50.0; // add a motor force to the pendulum motor

    // STENCIL: implement servo controller

    if (keyboard.pressed("c")||servo_active_persist) {
	console.log("if");
	var e_previous = pendulum.desired - pendulum.angle_previous;
	var e = pendulum.desired - pendulum.angle;
	accumulated_error = accumulated_error + e;
	pendulum.control = pendulum.servo.kp * e + pendulum.servo.ki * accumulated_error + pendulum.servo.kd * (e - e_previous)/dt; 
	
	servo_active_state = "active";	
        servo_active_persist = true; 
    }

    // disable motor from user interaction 
   
    if (keyboard.pressed("s")||!servo_active_persist) {
        pendulum.control = 0;
        accumulated_error = 0;
        servo_active_state = "disabled";
    	servo_active_persist = false;
    }
    else
        servo_active_state = "active";


    // integrate pendulum state forward in time by dt
    if (typeof numerical_integrator === "undefined")
        numerical_integrator = "none";

    if (numerical_integrator === "euler") {

    // STENCIL: a correct Euler integrator is REQUIRED for assignment
	pendulum.angle_previous = pendulum.angle;
	pendulum.angle = pendulum.angle_previous + pendulum.angle_dot*dt


//	pendulum.angle_init = (pendulum.angle+Math.PI/180)%(2*Math.PI);

//	pendulum.angle_dot_init = (pendulum.angle_init-pendulum.angle_previous)/dt;
	pendulum.angle_dot_dot = -gravity/pendulum.length*Math.sin(pendulum.angle_previous) + pendulum.control/(pendulum.mass*pendulum.length*pendulum.length);
	pendulum.angle_dot = pendulum.angle_dot + pendulum.angle_dot_dot*dt;
//	pendulum.angle = pendulum.angle + pendulum.angle_dot*dt;
    }
    else if (numerical_integrator === "verlet") {

    // STENCIL: basic Verlet integration
	if (ver_state == true){
	console.log("initializing");

	console.log(pendulum_2.angle);
	pendulum.angle_previous = pendulum.angle;
	pendulum_2.angle_previous = pendulum_2.angle;
//	pendulum.angle_dot_dot = -gravity/pendulum.length*Math.sin(pendulum.angle) + pendulum.control/(pendulum.mass*pendulum.length*pendulum.length);
	

	pendulum.angle_dot_dot = pendulum_acceleration(pendulum.angle,pendulum_2.angle,pendulum.angle_dot,pendulum_2.angle_dot,pendulum.control);
	pendulum_2.angle_dot_dot = pendulum_2_acceleration(pendulum.angle,pendulum_2.angle,pendulum.angle_dot,pendulum_2.angle_dot,pendulum.control);

	pendulum.angle_init = pendulum.angle + pendulum.angle_dot*dt + 0.5*pendulum.angle_dot_dot*dt*dt;   
	pendulum_2.angle_init = pendulum_2.angle + pendulum_2.angle_dot*dt + 0.5*pendulum_2.angle_dot_dot*dt*dt;   	

	pendulum.angle_current = pendulum.angle_init;
	pendulum_2.angle_current = pendulum_2.angle_init;

	pendulum.angle = 2*pendulum.angle_current - pendulum.angle_previous + pendulum.angle_dot_dot*dt*dt;
	pendulum_2.angle = 2*pendulum_2.angle_current - pendulum_2.angle_previous + pendulum_2.angle_dot_dot*dt*dt;

	pendulum.angle_dot = (pendulum.angle - pendulum.angle_previous)/(2*dt);
	pendulum_2.angle_dot = (pendulum_2.angle - pendulum_2.angle_previous)/(2*dt);

	ver_state = false;

	console.log(pendulum.angle_dot);
	console.log(pendulum.angle);


	}
	else if(ver_state == false){


	pendulum.angle_previous = pendulum.angle_current;
	pendulum.angle_current = pendulum.angle;
	pendulum.angle_dot_current = pendulum.angle_dot;

	pendulum_2.angle_previous = pendulum_2.angle_current;
	pendulum_2.angle_current = pendulum_2.angle;
	pendulum_2.angle_dot_current = pendulum_2.angle_dot;

	//pendulum.angle_dot_dot = -gravity/pendulum.length*Math.sin(pendulum.angle) + pendulum.control/(pendulum.mass*pendulum.length*pendulum.length);
	//pendulum.angle = pendulum.angle + pendulum.angle_dot*dt + 0.5*pendulum.angle_dot_dot*dt*dt;
	
	pendulum.angle = 2*pendulum.angle_current - pendulum.angle_previous + pendulum_acceleration(pendulum.angle_current,pendulum_2.angle_current,pendulum.angle_dot_current,pendulum_2.angle_dot_current,pendulum.control)*dt*dt;

	pendulum_2.angle = 2*pendulum_2.angle_current - pendulum_2.angle_previous + pendulum_2_acceleration(pendulum.angle_current,pendulum_2.angle_current,pendulum.angle_dot_current,pendulum_2.angle_dot_current,pendulum.control)*dt*dt;

	pendulum.angle_dot = (pendulum.angle - pendulum.angle_previous)/(2*dt);
	pendulum_2.angle_dot = (pendulum_2.angle - pendulum_2.angle_previous)/(2*dt);

	}
	//console.log(ver_state);
    }
    else if (numerical_integrator === "velocity verlet") {

    // STENCIL: a correct velocity Verlet integrator is REQUIRED for assignment
	pendulum.angle_previous = pendulum.angle;
	pendulum_2.angle_previous = pendulum_2.angle;

//	pendulum.angle_dot_dot_previous = -gravity/pendulum.length*Math.sin(pendulum.angle_previous) + pendulum.control/(pendulum.mass*pendulum.length*pendulum.length);
	
	pendulum.angle_dot_dot_previous = pendulum_acceleration(pendulum.angle_previous,pendulum_2.angle_previous,pendulum.control);
	pendulum_2.angle_dot_dot_previous = pendulum_2_acceleration(pendulum_2.angle_previous,pendulum.control);


	pendulum.angle = pendulum.angle_previous + pendulum.angle_dot*dt + 0.5*pendulum.angle_dot_dot_previous*dt*dt;
	pendulum_2.angle = pendulum_2.angle_previous + pendulum_2.angle_dot*dt + 0.5*pendulum_2.angle_dot_dot_previous*dt*dt;

	//pendulum.angle_dot_dot = -gravity/pendulum.length*Math.sin(pendulum.angle) + pendulum.control/(pendulum.mass*pendulum.length*pendulum.length);

	pendulum.angle_dot_dot = pendulum_acceleration(pendulum.angle,pendulum_2.angle,pendulum.control);
	pendulum_2.angle_dot_dot = pendulum_2_acceleration(pendulum_2.angle,pendulum.control);


	pendulum.angle_dot = pendulum.angle_dot + (pendulum.angle_dot_dot_previous + pendulum.angle_dot_dot)*0.5*dt;
	pendulum_2.angle_dot = pendulum_2.angle_dot + (pendulum_2.angle_dot_dot_previous + pendulum_2.angle_dot_dot)*0.5*dt;



    }
    else if (numerical_integrator === "runge-kutta") {

    // STENCIL: Runge-Kutta 4 integrator
	var a21 = 0.5, a32 = 0.5, a43 = 1, c1 = 0, c2 = 0.5, c3 = 0.5, c4 = 1, b1 = 1/6,  b2 = 1/3, b3 = 1/3, b4 = 1/6; 
	var x2=0,x3=0,x4=0,v2=0,v3=0,v4=0,X2=0,X3=0,X4=0,V2=0,V3=0,V4=0;
	pendulum.angle_previous = pendulum.angle;
	pendulum_2.angle_previous = pendulum_2.angle;	
//	var pendulum.angle_previous = pendulum.angle_dot;

	 x1= pendulum.angle;
	 v1 = pendulum.angle_dot; 

	 X1= pendulum_2.angle;
	 V1 = pendulum_2.angle_dot;
 
	 X2 = X1 + (a21 * V1 * dt);
//	console.log(x2);
	 //V2 = V1 + (a21 * pendulum_2_acceleration(X1, pendulum.control) * dt);
//	 X3 = X1 + (a32 * V2 * dt);
//	 V3 = V1 + (a32 * pendulum_2_acceleration(X2, pendulum.control) * dt );
//	 X4 = X1 + (a43 * V3 * dt);
//	 V4 = V1 + (a43 * pendulum_2_acceleration(X3, pendulum.control) * dt ); 

	 V2 = V1 + (a21 * pendulum_2_acceleration(x1,X1,v1,V1, pendulum.control) * dt);
	 X3 = X1 + (a32 * V2 * dt);
	 V3 = V1 + (a32 * pendulum_2_acceleration(x2,X2,v2,V2, pendulum.control) * dt );
	 X4 = X1 + (a43 * V3 * dt);
	 V4 = V1 + (a43 * pendulum_2_acceleration(x3,X3,v3,V3, pendulum.control) * dt ); 



	 x2 = x1 + (a21 * v1 * dt);
//	console.log(x2);
//	 v2 = v1 + (a21 * pendulum_acceleration(x1,X1, pendulum.control) * dt);
//	 x3 = x1 + (a32 * v2 * dt);
//	 v3 = v1 + (a32 * pendulum_acceleration(x2,X2, pendulum.control) * dt );
//	 x4 = x1 + (a43 * v3 * dt);
//	 v4 = v1 + (a43 * pendulum_acceleration(x3,X3, pendulum.control) * dt ); 

	 v2 = v1 + (a21 * pendulum_acceleration(x1,X1,v1,V1, pendulum.control) * dt);
	 x3 = x1 + (a32 * v2 * dt);
	 v3 = v1 + (a32 * pendulum_acceleration(x2,X2,v2,V2, pendulum.control) * dt );
	 x4 = x1 + (a43 * v3 * dt);
	 v4 = v1 + (a43 * pendulum_acceleration(x3,X3,v3,V3, pendulum.control) * dt ); 


	pendulum_2.angle = pendulum_2.angle + dt * (b1 * V1 + (b2 * V2) + (b3 * V3) + b4 * V4);
 
//	pendulum_2.angle_dot = pendulum_2.angle_dot + dt * (b1 * pendulum_2_acceleration(X1,pendulum.control)
// 				 + b2 * pendulum_2_acceleration(X2, pendulum.control)
// 				 + b3 * pendulum_2_acceleration(X3, pendulum.control)
//				 + b4 * pendulum_2_acceleration(X4, pendulum.control));
	
	pendulum_2.angle_dot = pendulum_2.angle_dot+ dt * (b1 * pendulum_2_acceleration(x1,X1,v1,V1,pendulum.control)
 				 + b2 * pendulum_2_acceleration(x2,X2,v2,V2, pendulum.control)
 				 + b3 * pendulum_2_acceleration(x3,X3,v3,V3, pendulum.control)
				 + b4 * pendulum_2_acceleration(x4,X4,v4,V4, pendulum.control));
	

		

	pendulum.angle = pendulum.angle + dt * (b1 * v1 + (b2 * v2) + (b3 * v3) + b4 * v4);
 
//	pendulum.angle_dot = pendulum.angle_dot + dt * (b1 * pendulum_acceleration(x1,X1,pendulum.control)
// 				 + b2 * pendulum_acceleration(x2,X2, pendulum.control)
// 				 + b3 * pendulum_acceleration(x3,X3, pendulum.control)
//				 + b4 * pendulum_acceleration(x4,X4, pendulum.control));
	pendulum.angle_dot = pendulum.angle_dot + dt * (b1 * pendulum_acceleration(x1,X1,v1,V1,pendulum.control)
 				 + b2 * pendulum_acceleration(x2,X2,v2,V2, pendulum.control)
 				 + b3 * pendulum_acceleration(x3,X3,v3,V3, pendulum.control)
				 + b4 * pendulum_acceleration(x4,X4,v4,V4, pendulum.control));
/*
	x1 = x2;
	v1 = v2;	
	v2 = v3;
	x2 = x3;
	v3 = v4;
	x3 = x4;
	pendulum.angle = x4;
	pendulum.angle_dot = v4;
	
	
*/	



    } 
    else {
        pendulum.angle_previous = pendulum.angle;
        pendulum.angle = (pendulum.angle+Math.PI/180)%(2*Math.PI);
        pendulum.angle_dot = (pendulum.angle-pendulum.angle_previous)/dt;
        numerical_integrator = "none";
      
        pendulum_2.angle_previous = pendulum_2.angle;
        pendulum_2.angle = (pendulum_2.angle+Math.PI/180)%(2*Math.PI);
        pendulum_2.angle_dot = (pendulum_2.angle-pendulum_2.angle_previous)/dt;
        numerical_integrator = "none";
 


     }

    // set the angle of the pendulum
    pendulum.geom.rotation.y = pendulum.angle;  // threejs cylinders have their axes along the y-axis

    pendulum_2.geom.rotation.y = pendulum_2.angle;

    pendulum_2.geom.position = {x:pendulum.length*Math.cos(pendulum.angle-Math.PI/2), y:1.5+pendulum.length*Math.sin(pendulum.angle-Math.PI/2), z:0};

  // console.log(pendulum_2.angle);
    // advance time
    t = t + dt;

    textbar.innerHTML = 
        "System <br> " +
        " t = " + t.toFixed(2) + 
        " dt = " + dt.toFixed(2) + 
        "<br>" +
        " integrator = " + numerical_integrator + 
        "<br>" +
        " x = " + pendulum.angle.toFixed(2) + 
        "<br>" +
        " x_dot = " + pendulum.angle_dot.toFixed(2) + 
        "<br>" +
        " x_desired = " + pendulum.desired.toFixed(2) + 
        "<br><br> Servo: " + servo_active_state + " <br> " +
        " u = " + pendulum.control.toFixed(2) +
        "<br>" +
        " kp = " + pendulum.servo.kp.toFixed(2) + 
        "<br>" +
        " kd = " + pendulum.servo.kd.toFixed(2) + 
        "<br>" +
        " ki = " + pendulum.servo.ki.toFixed(2) +
        "<br><br>  Pendulum <br> " +
        " mass = " + pendulum.mass.toFixed(2) +
        "<br>" +
        " length = " + pendulum.length.toFixed(2) +
        "<br>" +
        " gravity = " + gravity.toFixed(2) +
        "<br><br>  Keys <br> " +
        " [0-4] - select integrator " +
        "<br>" +
        " a/d - apply user force " +
        "<br>" +
        " q/e - adjust desired angle " +
        "<br>" +
        " c - toggle servo " +
        "<br>" +
        " s - disable servo "

    ;

    // threejs rendering update
    renderer.render( scene, camera );

}

//function pendulum_acceleration(p1,p2,u){

function pendulum_acceleration(p1,p2,w1,w2,u) {
    // STENCIL: return acceleration(s) system equation(s) of motion 
//	var result = -gravity/pendulum.length*Math.sin(p1) + g/(pendulum.mass*pendulum.length*pendulum.length);
//	var result = -gravity/pendulum.length*Math.sin(p1) + pendulum_2.mass*gravity*Math.cos(p2)*Math.sin(p2-p1)/(pendulum.mass*pendulum.length)+u/(pendulum.mass*pendulum.length)*Math.sin(p2)*Math.sin(p2-p1);

//different EOM
	var result =(pendulum_2.mass*pendulum.length*Math.pow(w1,2)*Math.sin(p2-p1)*Math.cos(p2-p1) + 
		pendulum_2.mass*gravity*Math.sin(p2)*Math.cos(p2-p1) + 
		pendulum_2.mass*pendulum_2.length*Math.pow(w2,2)*Math.sin(p2-p1) - 
		(pendulum.mass+pendulum_2.mass)*gravity*Math.sin(p1))/
		((pendulum.mass+pendulum_2.mass)*pendulum.length - pendulum_2.mass*pendulum.length*Math.pow(Math.cos(p2-p1),2));


	return result;

}


//function pendulum_acceleration(p2,u){
function pendulum_2_acceleration(p1,p2,w1,w2,u) {

//	var result2 = -gravity/pendulum_2.length*Math.sin(p2) + Math.cos(p2)/(pendulum_2.mass*pendulum_2.length)*u;
	var result2 =(-pendulum_2.mass*pendulum_2.length*Math.pow(w2,2)*Math.sin(p2-p1)*Math.cos(p2-p1) +
		( pendulum_2.mass+pendulum.mass)*(gravity*Math.sin(p1)*Math.cos(p2-p1)- 
		pendulum.length*Math.pow(w1,2)*Math.sin(p2-p1) - 
		gravity*Math.sin(p2)))/
		((pendulum.mass+pendulum_2.mass)*pendulum_2.length - pendulum_2.mass*pendulum_2.length*Math.pow(Math.cos(p2-p1),2));


	return result2;


}

function createScene() {

    // instantiate threejs scene graph
    scene = new THREE.Scene();

    // instantiate threejs camera and set its position in the world
    camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 10000 );
    camera.position.y = 1;
    camera.position.z = 4;

    var light1 = new THREE.PointLight( 0xffffff, 0.3, 1000 ); 
    light1.position.set( 10, 10, 10 ); 
    scene.add( light1 );

    var light2 = new THREE.PointLight( 0xffffff, 0.3, 1000 ); 
    light2.position.set( 10, -10, 10 ); 
    scene.add( light2 );

    var light3 = new THREE.PointLight( 0xffffff, 0.3, 1000 ); 
    light3.position.set( -10, -10, 10 ); 
    scene.add( light3 );

    var light4 = new THREE.PointLight( 0xffffff, 0.3, 1000 ); 
    light4.position.set( -10, 10, 10 ); 
    scene.add( light4 );

    // instantiate threejs renderer and its dimensions
    renderer = new THREE.WebGLRenderer();
    renderer.setSize( window.innerWidth, window.innerHeight );

    // attach threejs renderer to DOM
    document.body.appendChild( renderer.domElement );

    // instantiate threejs camera controls
    camera_controls = new THREE.OrbitControls( camera );
    camera_controls.addEventListener( 'change', renderer );

    // instantiate threejs keyboard controls, for continuous interactive controls
    keyboard = new THREEx.KeyboardState();

    textbar = document.createElement('div');
    textbar.style.position = 'absolute';
    //textbar.style.zIndex = 1;    // if you still don't see the label, try uncommenting this
    textbar.style.width = window.width-10;
    textbar.style["font-family"] = "Monospace";
    textbar.style.height = 20;
    //textbar.style.backgroundColor = "black";
    textbar.style.color = "#000000";
    textbar.innerHTML = "M4PRoGReS - pendularm!";
    textbar.style.top = 10 + 'px';
    textbar.style.left = 10 + 'px';
    document.body.appendChild(textbar);

    temp_geom = new THREE.CylinderGeometry(0.2, 0.2, 3.5, 20, 20, false);
    temp_material = new THREE.MeshLambertMaterial( { } );
    temp_material.color.r = 1;
    temp_material.color.g = 1;
    temp_material.color.b = 1;
    temp_material.color.b = 1;
    temp_material.transparent = true;
    temp_material.opacity = 0.3;

    leg1 = new THREE.Mesh(temp_geom, temp_material);
    leg2 = new THREE.Mesh(temp_geom, temp_material);
    leg3 = new THREE.Mesh(temp_geom, temp_material);
    leg4 = new THREE.Mesh(temp_geom, temp_material);
    leg1.position = {x:2,z:1,y:0};
    leg2.position = {x:-2,z:1,y:0};
    leg3.position = {x:-2,z:-1,y:0};
    leg4.position = {x:2,z:-1,y:0};
    scene.add(leg1);
    scene.add(leg2);
    scene.add(leg3);
    scene.add(leg4);

    temp_geom = new THREE.CylinderGeometry(0.2, 0.2, 4.0, 20, 20, false);
    sidebar1 = new THREE.Mesh(temp_geom, temp_material);
    sidebar1.rotateOnAxis(new THREE.Vector3(0,0,1),Math.PI/2);
    sidebar1.position = {x:-2,z:0,y:1.5};
    leg1.add(sidebar1);
    sidebar2 = new THREE.Mesh(temp_geom, temp_material);
    sidebar2.rotateOnAxis(new THREE.Vector3(0,0,1),Math.PI/2);
    sidebar2.position = {x:2,z:0,y:1.5};
    leg3.add(sidebar2);

    temp_geom = new THREE.CylinderGeometry(0.2, 0.2, 2.0, 20, 20, false);
    crossbar = new THREE.Mesh(temp_geom, temp_material);
    crossbar.rotateOnAxis(new THREE.Vector3(1,0,0),Math.PI/2);
    crossbar.position = {x:0,z:-1,y:0};
    sidebar1.add(crossbar);

    temp_geom = new THREE.CylinderGeometry(0.3, 0.3, 0.3, 20, 20, false);

    temp_material = new THREE.MeshLambertMaterial( { } );
    temp_material.color.r = 1;
    temp_material.color.g = 0;
    temp_material.color.b = 1;
    temp_material.transparent = false;

    pendulum.geom = new THREE.Mesh(temp_geom, temp_material);
    pendulum.geom.rotateOnAxis(new THREE.Vector3(1,0,0),Math.PI/2);
   // crossbar.add(pendulum.geom);
    scene.add(pendulum.geom);
    pendulum.geom.position = {x:0,y:1.5,z:0};

    temp_geom = new THREE.CylinderGeometry(0.2, 0.2, pendulum.length, 20, 20, false);
    pendulum_link = new THREE.Mesh(temp_geom, temp_material);
    pendulum_link.rotateOnAxis(new THREE.Vector3(1,0,0),-Math.PI/2);
    pendulum_link.position = {x:0,z:pendulum.length/2,y:0};
    pendulum.geom.add(pendulum_link);

    temp_geom = new THREE.SphereGeometry(Math.sqrt(pendulum.mass*0.1));
    pendulum_mass = new THREE.Mesh(temp_geom, temp_material);
    pendulum_mass.position = {x:0,y:-pendulum.length/2,z:0};
    pendulum_link.add(pendulum_mass);

 //  add new geometry
/*
    temp_geom_2 = new THREE.CylinderGeometry(0.2, 0.2, 2.0, 20, 20, false);    crossbar_2 = new THREE.Mesh(temp_geom, temp_material);
    crossbar_2.rotateOnAxis(new THREE.Vector3(1,0,0),Math.PI/2);
    crossbar_2.position = {x:0,z:-3,y:0};
    pendulum_link.add(crossbar_2);
*/
//
 

    //console.log(pendulum.angle);

    pendulum_2.geom = new THREE.Mesh(temp_geom, temp_material);
    pendulum_2.geom.rotateOnAxis(new THREE.Vector3(1,0,0),Math.PI/2);
   // crossbar.add(pendulum.geom);
    scene.add(pendulum_2.geom);
    pendulum_2.geom.position = {x:2*Math.cos(pendulum.angle),y:2*Math.cos(pendulum.angle),z:0};
 //   pendulum_2.geom.position = pendulum_mass.position;
    pendulum_link.add(pendulum_2);

    temp_geom = new THREE.CylinderGeometry(0.2, 0.2, pendulum.length, 20, 20, false);
    pendulum_link_2 = new THREE.Mesh(temp_geom, temp_material);
    pendulum_link_2.rotateOnAxis(new THREE.Vector3(1,0,0),-Math.PI/2);
    pendulum_link_2.position = {x:0,z:pendulum_2.length/2,y:0};
    pendulum_2.geom.add(pendulum_link_2);

    temp_geom = new THREE.SphereGeometry(Math.sqrt(pendulum.mass*0.1));
    pendulum_mass = new THREE.Mesh(temp_geom, temp_material);
    pendulum_mass.position = {x:0,y:-pendulum_2.length/2,z:0};
    pendulum_link_2.add(pendulum_mass);







}

</script>
</body>
</html>


