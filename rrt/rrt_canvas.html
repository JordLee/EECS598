
<!-- |\/| |\/| |\/| |\/| |\/| |\/| |\/| |\/| |\/| |\/| |\/| |\/| |\/| |\/| |\/|

    RRT-Canvas

    Rapidly-exploring Random Tree example in HTML5 Canvas
    based on RRT and RRT-Connect algorithms by Kuffner and LaValle (2000)

    @author ohseejay / https://github.com/ohseejay / https://bitbucket.org/ohseejay

    Chad Jenkins
    Laboratory for Perception RObotics and Grounded REasoning Systems
    University of Michigan

    License: Creative Commons 3.0 BY-SA

|\/| |\/| |\/| |\/| |\/| |\/| |\/| |\/| |\/| |\/| |\/| |\/| |\/| |\/| |\/| -->

<html>

<body onload="init()">

<canvas id="myCanvas" width=800 height=800 style="z-index: 10 ;border:1px solid #000000;">
</canvas> 

<script>

//////////////////////////////////////////////////
/////     INITIALIZATION FUNCTION DEFINITONS
//////////////////////////////////////////////////

function init() {

    // specify rrt algorithm to use for planning
    rrt_alg = 1;  // 0: basic rrt, 1: rrt_connect

    // set the world for the planner 
    //  (stored as "range" global variable with name "planning_scene")
    //planning_scene = "empty";
    planning_scene = "misc";
    //planning_scene = "narrow1";
    //planning_scene = "narrow2";
    //planning_scene = "three_sections";
    set_planning_scene();

    // specify threshold radius for step size and when goal is reached
    eps = 0.1;

    // specify start and goal configurations
    q_start_config = [0,0];
    q_goal_config = [4,4];
    q_init = q_start_config;
    q_goal = q_goal_config;

    // initialize search graphs from start and goal configurations
    T_a = tree_init(q_init);
    T_b = tree_init(q_goal);

    // flag to continue rrt iterations
    rrt_iterate = true;
    rrt_iter_count = 0;
    rrt_max_iterations = 10000;

    // make sure the rrt iterations are not running faster than animation update
    cur_time = Date.now();

    // create textbar for text output 
    textbar = document.createElement('div');
    textbar.style.position = 'absolute';
    //textbar.style.zIndex = 1;    // if you still don't see the label, try uncommenting this
    textbar.style.width = window.width-10;
    textbar.style["font-family"] = "Monospace";
    textbar.style.height = 20;
    textbar.style.color = "#000000";
    textbar.innerHTML = "M4PRoGReS - RRT Canvas";
    textbar.style.top = 30 + 'px';
    textbar.style.left = 30 + 'px';
    document.body.appendChild(textbar);

    // main animation loop maintained by threejs 
    animate();
}


//////////////////////////////////////////////////
/////     ANIMATION AND INTERACTION LOOP
//////////////////////////////////////////////////

function animate() {

    // alternative to using setInterval for updating in-browser drawing
    // this effectively request that the animate function be called again for next draw
    // http://learningwebgl.com/blog/?p=3189
    requestAnimationFrame( animate );

    draw_robot_world();

    // make sure the rrt iterations are not running faster than animation update
    if (rrt_iterate && (Date.now()-cur_time > 10)) {

        // update time marker for last iteration update
        cur_time = Date.now();

    // STENCIL: implement single rrt iteration here. an asynch timing mechanism 
    //   is used instead of a for loop to avoid blocking and non-responsiveness 
    //   in the browser.
    //
    //   provided support functions:
    //
    //   collision_test - returns whether a given configuration is in collision
    //   tree_init - creates a tree of configurations
    //   tree_add_vertex - adds and displays new configuration vertex for a tree
    //   tree_add_edge - adds and displays new tree edge between configurations
    //   draw_highlighted_path - renders a highlighted path in a tree
	stepsize = 0.2;
	numbq = 500;
	radius = 2; 

	
	 rrt_extend(T_a);


	

	}

//	draw_highlighted_path(T_a);
}


//////////////////////////////////////////////////
/////     STENCIL SUPPORT FUNCTIONS
//////////////////////////////////////////////////

function draw_robot_world() {

    // draw start and goal configurations
    c = document.getElementById("myCanvas");
    ctx = c.getContext("2d");
    ctx.fillStyle = "#0000FF";
    ctx.fillRect((q_init[0]*100+200)-5,(q_init[1]*100+200)-5,10,10);
    ctx.fillStyle = "#00FF00";
    ctx.fillRect((q_goal[0]*100+200)-5,(q_goal[1]*100+200)-5,10,10);

    // draw robot's world
    for (j=0;j<range.length;j++) { 
        ctx.fillStyle = "#8888FF";
        ctx.fillRect((range[j][0][0]*100+200),(range[j][1][0]*100+200),(range[j][0][1]-range[j][0][0])*100,(range[j][1][1]-range[j][1][0])*100);
    }
 
}

function draw_highlighted_path(path) {
    ctx = c.getContext("2d");
    ctx.strokeStyle="#0000FF";
    ctx.lineWidth=4;
    ctx.beginPath();
    for (i=1;i<path.length;i++) {
        ctx.moveTo(path[i-1].vertex[0]*100+200,path[i-1].vertex[1]*100+200);
        ctx.lineTo(path[i].vertex[0]*100+200,path[i].vertex[1]*100+200);
    }
    ctx.stroke();
}

function set_planning_scene() {

    // obstacles specified as a range along [0] (x-dimension) and [1] y-dimension
    range = []; // global variable

    // world boundary
    range[0] = [ [-1.8,5.8],[-1.8,-1] ];
    range[1] = [ [-1.8,5.8],[5,5.8] ];
    range[2] = [ [-1.8,-1], [-1.8,5.8] ];
    range[3] = [ [5,5.8],   [-1.8,5.8] ];

    if (typeof planning_scene === 'undefined')
        planning_scene = 'empty';

    if (planning_scene == 'misc') {
        /*  misc stuff with narrow opening */
        range[4] = [ [1,2],[1,2] ];
        range[5] = [ [3,3.3],[1,4] ];
        range[6] = [ [0.6,0.7],[0.4,0.7] ];
        range[7] = [ [3.7,3.9],[-0.8,5] ];
    }
    else if (planning_scene == 'narrow1') {
        /*  narrow path 1 */
        range[4] = [ [1,3],[4,5] ];
        range[5] = [ [1,3],[-1,2] ];
        range[6] = [ [1,1.95],[2,3.8] ];
    }
    else if (planning_scene == 'narrow2') {
        /*  narrow path 2 */
        range[4] = [ [1,3],[4,5] ];
        range[5] = [ [1,3],[-1,2] ];
        range[6] = [ [1,1.9],[2,3.8] ];
        range[7] = [ [2.1,3],[2.2,4] ];
    }
    else if (planning_scene == 'three_sections') {
        /*  three compartments */
        range[4] = [ [1,1.3],[4,5] ];
        range[5] = [ [1,1.3],[-1,3.5] ];
        range[6] = [ [2.7,3],[-1,0] ];
        range[7] = [ [2.7,3],[.5,5] ];
    }
}

function collision_test(q) {

    var j;

    // test for collision with each object
    for (j=0;j<range.length;j++) { 

        // assume configuration is in collision
        var in_collision = true; 

        // no collision detected, if configuration is outside obstacle along any dimension
        for (i=0;i<q.length;i++) { 
            if ((q[i]<range[j][i][0])||(q[i]>range[j][i][1]))
                in_collision = false;
        }
    
        // return collision, if configuration inside obstacle extents along all dimensions
        if (in_collision)
            return true;
    }

    // return no collision, if no collision detected with any obstacle
    return false;
}

function tree_init(q) {

    // create tree object
    var tree = {};

    // initialize with vertex for given configuration
    tree.vertices = [];
    tree.vertices[0] = {};
    tree.vertices[0].vertex = q;
    tree.vertices[0].edges = [];
    tree.vertices[0].cost = [];
    // maintain index of newest vertex added to tree
    tree.newest = 0;

    return tree;
}

function tree_add_vertex(tree,q) {

    // create new vertex object for tree with given configuration and no edges
    new_vertex = {};
    new_vertex.edges = [];
    new_vertex.vertex = q;
    new_vertex.cost = tree.vertices[tree.newest].cost;
    tree.vertices.push(new_vertex);
    tree.vertices.push
    // maintain index of newest vertex added to tree
    tree.newest = tree.vertices.length - 1;

    // draw location on canvas
    draw_2D_configuration(q);
}
function draw_2D_configuration(q) {
    // draw location of 2D configuration on canvas
    c = document.getElementById("myCanvas");
    ctx = c.getContext("2d");
    ctx.fillStyle = "#8888AA";
    ctx.fillRect((q[0]*100+200)-3,(q[1]*100+200)-3,6,6);
}

function draw_2D_edge_configurations(q1,q2) {
    // draw line between locations of two 2D configurations on canvas
    c = document.getElementById("myCanvas");
    ctx = c.getContext("2d");
    ctx.beginPath();
    ctx.moveTo(q1[0]*100+200,q1[1]*100+200);
    ctx.lineTo(q2[0]*100+200,q2[1]*100+200);
    ctx.stroke();
}

function tree_add_edge(tree,q1_idx,q2_idx) {

    // add edge to first vertex as pointer to second vertex
    tree.vertices[q1_idx].edges.push(tree.vertices[q2_idx]);

    // add edge to second vertex as pointer to first vertex
    tree.vertices[q2_idx].edges.push(tree.vertices[q1_idx]);

    // draw edge on canvas
    draw_2D_edge_configurations(tree.vertices[q1_idx].vertex,tree.vertices[q2_idx].vertex); 
}

//////////////////////////////////////////////////
/////     RRT IMPLEMENTATION FUNCTIONS
//////////////////////////////////////////////////

    // STENCIL: implement RRT-Connect functions here, such as:
    //   rrt_extend
    //   rrt_connect
    //   random_config
    //   new_config
    //   nearest_neighbor
    //   find_path
    //   path_dfs
function rrt_extend(tree){
//	for (var i=0;i<numbq;i++){
//
//	var q_rand = random_config();
//	var nn = tree.vertices[0];
//		for (var p=0;p<tree.vertices.length;p++){
//			if (vector_distance(tree.vertices[p].vertex,q_rand) < vector_distance(nn.vertex,q_rand)){
//			nn = tree.vertices[0];
//			}
//		inter_node = steer(nn.vertex,q_rand);
//
//		}
//
//	newnode = tree_init(inter_node);
//	[newnode,nn,q_near_index]=choose_parent(nn,newnode,tree);
//	tree_add_vertex(newnode,nn.vertex);
//	tree_add_edge(newnode,q_near_index,tree.newest);
//
//
//
//    	}

	 q_rand = random_config();
	 q_nearest = nearest_neighbor(q_rand,tree);
	var q_nearest_index=q_nearest[0];
	var q_nearest = q_nearest[1];
	 q_new = steer(q_nearest,q_rand);
    
	if (collision_test(q_new)==false){
      		 Q_near = near_vertices(q_new,tree);
		 q_min = choose_parent(Q_near,q_nearest,q_nearest_index,q_new,tree);
		 q_min_index = index_find(q_min,tree);
		insert_node(q_min,q_new,tree,q_min_index,tree.newest);
	//	q_new_index = index_find(q_new,tree);
		tree= rewire(tree,Q_near,q_min,q_new);
		q_min_index = index_find(q_min,tree);
		q_new_index = index_find(q_new,tree);
		tree_add_vertex(tree,q_new);
		tree_add_edge(tree,q_min_index,tree.newest);


	} 				 
	
	if (vector_distance(q_new,q_goal) < stepsize){
	rrt_iterate =false; 
	
	q_min_index = index_find(q_min,tree);
	var motion_plan =[];
	find_path(tree.vertices[q_min_index],motion_plan);

		
	draw_highlighted_path(A);
	
	}

}

function find_path(tree,motion_plan){
var k = motion_plan.length;
motion_plan.push(tree);

if (vector_distance(tree.vertex,q_init) < stepsize){
	A = motion_plan;
	return;

	}
console.log(motion_plan);
find_path(tree.edges[0],motion_plan);

}
function insert_node(q_current,q_new,tree,q_current_index,q_new_index) {

tree_add_vertex(tree,q_new);
//tree_add_edge(tree,q_current_index,q_new_index);


}
function index_find(q,tree){

	for ( var i=0 ; i<tree.vertices.length; i++){
		if (q == tree.vertices[i].vertex)
		return i
	}
}

function nearest_neighbor(q,tree) {
	var  distance = [];

        for ( i = 0; i< tree.vertices.length;i++){
        distance[i]=vector_distance(q,tree.vertices[i].vertex);
//	console.log(distance); 
     }
        nearest_index = distance.indexOf(Math.min(...distance));
       return [nearest_index,tree.vertices[nearest_index].vertex]

}

function near_vertices(q,tree) {
	gamma = 10;
	var n = tree.vertices.length;
	var l = gamma*(Math.log(n)/n);
	var Z = [];
	var Q =[];
	for (var i=0;i<tree.vertices.length;i++) {
	
		if (i==0)
		Q.push(tree.vertices[0]);
	
		else if (vector_distance(q,tree.vertices[i].vertex) <= l)
	 	Q.push(tree.vertices[i]);
	
	}
	//console.log(Q);
	return Q;

}


function random_config() {

var q_rand = [];

q_rand[0] = Math.random()*(range[3][0][0]-range[0][0][0]) + range[0][0][0];
q_rand[1] = Math.random()*(range[3][0][1]-range[2][0][1]) + range[2][0][1]; 

	if (collision_test(q_rand)==false) 
	return q_rand
}


function steer(q1,q2) {

	if (vector_distance(q1,q2) < stepsize)
	return q2
	else{
	var theta = Math.atan2(q2[1]-q1[1],q2[0]-q1[0]);
	return [q1[0] + stepsize*Math.cos(theta), q1[1] + stepsize*Math.sin(theta)];
 	}
}

function choose_parent(Q_near,q_nearest,q_nearest_index,q_new,tree){
	var q_min = q_nearest;
	var c_min = vector_distance(q_new,tree.vertices[0].vertex) + tree.vertices[q_nearest_index].cost;
	for(var p=0;p<Q_near.length;p++){

		var q_prime = steer(Q_near[p].vertex,q_new);
		if (collision_test(q_prime)==false && (q_prime == q_new)){
			//console.log("if");
			c_prime = Q_near[p].cost + vector_distance(q_new,tree.vertices[0].vertex);
//		if ((vector_distance(tree.vertices[p].vertex,newnode.vertices[0].vertex)< radius) && tree.vertices[p].cost + vector_distance(tree.vertices[p].vertex,newnode.vertices[0].vertex)< nn.cost + vector_distance(nn.vertex,newnode.vertices[0].vertex)){

			if ((c_prime < tree.vertices[tree.newest].cost) && (c_prime < c_min)) 
					q_min = Q_near[p].vertex;
		}
	}

return q_min


//		var nn = tree.vertices[p];
//		 q_near_index = p;
//		console.log("if");
//		}
//	
//	newnode.cost = nn.cost + vector_distance(nn.vertex,newnode.vertices[0].vertex);
//	}
//	newnode.edges[0] = nn;
//
//	
//	return [newnode, nn, q_near_index]
//
}
	

function rewire(tree,Q_near,q_min,q_new){
//	for (var i=0;i<nodes.vertices.length;i++){
//		var p = nodes.vertices[i];
//		if (p !== tree.vertices.edges[0] && vector_distance(p.vertex,newnode.vertex) < p.cost){
//			p.edges[0] = newnode;
//			p.cost = newnode.cost + vector_distance(p.vertex,newnode.vertex);
//			nodes.vertices[i] = p;
//
//		}	
//	}
//	return nodes

	for (var i=0; i<Q_near.length;i++) {
	var q_prime = steer(q_new,Q_near[i].vertex);
		if ((collision_test(q_prime)==false) && (q_prime == Q_near[i].vertex) &&(tree.vertices[tree.newest].cost+vector_distance(q_prime,tree.vertices[0].vertex)<Q_near[i].cost))
		Q_near[i].edges[0]=q_new;
	}

return tree 



}

function vector_distance(x,y){

var result=[];
var sum=0;
for (var i=0;i<x.length;i++){
result[i]=x[i]-y[i];
}
for (var i=0;i<x.length;i++){
sum = sum + result[i]*result[i];
}
sum= Math.sqrt(sum);
return sum;

}
</script>


</body>
</html>


